# StringBuilder 和 StringBuffer

### 1. GC效率
GC就是垃圾回收

String是不可变对象, 我们在使用+拼接字符串的时候, 总是会不断创建新的字符串对象, 并扔掉旧的, 绝大部分都是临时对象, 这样会造成内存浪费, 进而影响GC的效率(太频繁做无意义的事). 而在javaGC机制里, 当前大部分虚拟机才用的是 分代收集 方法, 根据对象的生命周期将堆分为新生代和老年代, 新生代对象的生存期短, 往往采用复制算法, 老年代采用标记-整理或者清除.

复制方法: 大概意思就是, 分割内存, 主区存满了就转移到副区, 清除主区, 副区塞不下的就踢到老年代里面.
标记-整理或者清除: 字面意思就是,针对老年代活的久远的对象, 标记它, 之后统一回收.

### 2.StringBuilder
可变长, 可以预分配缓冲区, 一旦满了就扩容, 尽量避免扩容, 扩容就意味着内部要复制原数组.
有个特点是, 它的实现是链式操作, 就是它的方法会return this, 这点在python里非常常用.

1)一定要避免+的字符串拼接操作嘛?
对于普通的字符串+操作，并不需要我们将其改写为StringBuilder，因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作.

这里需要注意的是, 在做算法题的时候, 通过预分配的StringBuilder往往能减少扩容, 数组复制等操作, 从而带来性能的提升. 并不是说用+拼接就带来损耗, +隐式就是StringBuilder.

### 3.StringBuffer
据说这是一个早期的StringBuilder的线程安全版本, 它俩接口完全相同. 据说这是一个基本上没有任何使用场景的存在. 主要是因为现有它再有StringBuilder. 所谓的线程安全其实只是让JVM不抛出异常. 
